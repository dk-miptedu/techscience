
**Цели недели 3.**
    
    В результате обучения на этой неделе вы: 
    
    - научитесь решать задачи линейной классификации в машинном обучении
    - познакомитесь с понятием правдоподобия в задачах машинного обучения
    - поймете, как использовать модель логистической регрессии в задачах бинарной и мультиклассовой классификации
    - узнаете различные метрики оценки качества классификации
    
## 3.1 Задача линейной классификации

Ссылка на видео: [https://disk.yandex.ru/i/XapdC0D1obSEqg](https://disk.yandex.ru/i/XapdC0D1obSEqg)  
    
## 3.2 Правдоподобие
Ссылка на видео: [https://disk.yandex.ru/i/RLsND3dwutKoDQ](https://disk.yandex.ru/i/RLsND3dwutKoDQ)  
    
## 3.3 Логистическая регрессия
Ссылка на видео: [https://disk.yandex.ru/i/D9VraGWeYIo8rA](https://disk.yandex.ru/i/D9VraGWeYIo8rA)  
    
## 3.4 Мультиклассовая классификация
    
Ссылка на видео: [https://disk.yandex.ru/i/7kR_cn56SiXAtA](https://disk.yandex.ru/i/7kR_cn56SiXAtA)  
    
# **Дополнительные материалы**

## 3.5 Конспект занятия
    
![3.5.Конспект (Модуль 4 Неделя 3](./assets/3.5.Конспект%20(Модуль%204%20Неделя%203).pdf)
    
# **Проверочные задания**
    
## 3.6 Итоговый тест 1

![3.6 Итоговый тест 1-01.pdf](./assets/3.6%20Итоговый%20тест%201-01.pdf)  
   
## 3.7 Задание на программирование 3

### Задача № 1
Импортируйте `torch` и сохраните его версию в переменную version
```python
# Import torch and save its version into the corresponding variable
# your code here
# После перезагрузки состояния кода, необходимо повторно выполнить импорт и код
import torch
import re  

# Сохраняем версию torch в переменную
version = torch.__version__

# do not change the code in the block below
# __________start of block__________
assert version is not None, 'Please, save torch version'
major_version, minor_version = re.findall("\d+\.\d+", version)[0].split('.')
assert float(major_version) >= 2 or (float(major_version) >= 1 and float(minor_version) >= 7), 'Please, update PyTorch'
# __________end of block__________
condition = float(major_version) >= 2 or (float(major_version) >= 1 and float(minor_version) >= 7)
version, condition
```

Теперь импортируйте модуль `nn` и внутри функции `create_model` постройте нейронную сеть из трех линейных слоев, последовательно отображающих данные в промежуточные (скрытые) представления размерностей 256, 16 и 10. Не забывайте о свободном члене (bias).

Исходные данные имеют размерность 784. В качестве функций активации используйте ReLU.

```python
import numpy as np
import torch
from torch import nn

def create_model():
    # your code here
    # return model instance (None is just a placeholder)
    model = nn.Sequential(
        nn.Linear(784, 256), # Первый линейный слой с 784 входами и 256 выходами
        nn.ReLU(),           # Функция активации ReLU после первого линейного слоя
        nn.Linear(256, 16),  # Второй линейный слой с 256 входами и 16 выходами
        nn.ReLU(),           # Функция активации ReLU после второго линейного слоя
        nn.Linear(16, 10)    # Третий линейный слой с 16 входами и 10 выходами
    )
    return model
```

Реализуйте функцию для подсчета количества параметров в модели (вам может помочь `model.parameters()`).

На вход она принимает модель, на выход возвращает одно число – количество параметров в модели.
```python

def count_parameters(model):
    # your code here
    # return integer number (None is just a placeholder)
    
    return sum(p.numel() for p in model.parameters() if p.requires_grad)
```